!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?module.exports=r(require("three"),require("double-buffer")):"function"==typeof define&&define.amd?define(["three","double-buffer"],r):(e||self).blurCanvas=r(e.three,e.doubleBuffer)}(this,function(e,r){function t(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var n=t(r);return function(){function r(r){void 0===r&&(r={});var t=r.width,i=r.height;this.renderer=r.renderer,this.iterations=r.iterations||8,this.fbo=new n.default({width:t,height:i}),this.scene=new e.Scene,this.camera=new e.OrthographicCamera(-.5,.5,.5,-.5,.1,2),this.camera.position.set(0,0,1),this.camera.lookAt(new e.Vector3),this.setupPlane()}var t=r.prototype;return t.blur=function(e){this.plane.material.uniforms.u_blur_amount.value=0,this.plane.material.uniforms.u_source_texture.value=e,this.plane.material.uniforms.u_image_dimensions.value=[e.image.width,e.image.height],this.plane.material.needsUpdate=!0,this.render(),this.plane.material.uniforms.u_blur_amount.value=1;for(var r=0;r<this.iterations;r+=1){var t=this.iterations-r-1;this.plane.material.uniforms.u_blur_direction.value=r%2==0?[t,0]:[0,t],this.render()}},t.setupPlane=function(r,t){this.plane=new e.Mesh(new e.PlaneGeometry(r,t),this.createMaterial()),this.scene.add(this.plane)},t.getCurrentTexture=function(){return this.fbo.read().texture},t.render=function(){this.renderer.setRenderTarget(this.fbo.write()),this.renderer.render(this.scene,this.camera),this.fbo.swap(),this.plane.material.uniforms.u_buffer_texture.value=this.fbo.read().texture},t.createMaterial=function(){return new e.ShaderMaterial({transparent:!0,side:e.DoubleSide,uniforms:{u_buffer_texture:{value:this.fbo.read().texture,type:"t"},u_source_texture:{value:null,type:"t"},u_blur_amount:{value:0},u_blur_direction:{value:[0,0]},u_image_dimensions:{value:[0,0]}},vertexShader:"\n        varying vec2 vUv;\n\n        void main() {\n          vUv = uv;\n\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      ",fragmentShader:"\n        varying vec2 vUv;\n        uniform sampler2D u_source_texture;\n        uniform sampler2D u_buffer_texture;\n        uniform float u_blur_amount;\n        uniform vec2 u_blur_direction;\n        uniform vec2 u_image_dimensions;\n\n        // from glsl-fast-gaussian-blur by jam3\n        vec4 blur13(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n          vec4 color = vec4(0.0);\n          vec2 off1 = vec2(1.411764705882353) * direction;\n          vec2 off2 = vec2(3.2941176470588234) * direction;\n          vec2 off3 = vec2(5.176470588235294) * direction;\n\n          color += texture2D(image, uv) * 0.1964825501511404;\n\n          color += texture2D(image, uv + (off1 / resolution)) * 0.2969069646728344;\n          color += texture2D(image, uv - (off1 / resolution)) * 0.2969069646728344;\n\n          color += texture2D(image, uv + (off2 / resolution)) * 0.09447039785044732;\n          color += texture2D(image, uv - (off2 / resolution)) * 0.09447039785044732;\n\n          color += texture2D(image, uv + (off3 / resolution)) * 0.010381362401148057;\n          color += texture2D(image, uv - (off3 / resolution)) * 0.010381362401148057;\n          return color;\n        }\n\n        void main() {\n          vec4 source_color = texture2D(u_source_texture, vUv);\n          vec4 map = blur13(\n            u_buffer_texture,\n            vUv,\n            u_image_dimensions,\n            u_blur_direction\n          );\n\n          vec4 color = mix(source_color, map, u_blur_amount);\n\n          gl_FragColor = color;\n        }\n      "})},r}()});
//# sourceMappingURL=index.umd.js.map
